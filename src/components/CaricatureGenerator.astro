---
import { config } from '../config';
---

<div class="max-w-4xl mx-auto p-6">
  <div class="bg-white rounded-lg shadow-lg p-8">
    <h2 class="text-3xl font-bold text-gray-900 mb-8 text-center">Caricature Generator</h2>
    
    <div class="grid lg:grid-cols-2 gap-8">
      <!-- Original Image -->
      <div class="space-y-6">
        <div class="text-center">
          <h3 class="text-xl font-semibold text-gray-900 mb-4">Original Photo</h3>
          <div class="bg-gray-100 rounded-lg p-4 inline-block relative">
            <canvas id="original-canvas" width="400" height="400" class="border border-gray-300 rounded max-w-full" style="display: block; background: white;"></canvas>
            <div id="original-placeholder" class="absolute inset-0 flex items-center justify-center text-gray-500 pointer-events-none">
              <div class="text-center">
                <div class="text-4xl mb-2">ðŸ“·</div>
                <div class="text-sm">Upload a photo to get started</div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Image Upload -->
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            Upload Photo for Caricature
          </label>
          <input 
            type="file" 
            id="caricature-upload" 
            accept="image/*" 
            class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-primary-50 file:text-primary-700 hover:file:bg-primary-100"
          />
        </div>
      </div>

      <!-- Caricature Result -->
      <div class="space-y-6">
        <div class="text-center">
          <h3 class="text-xl font-semibold text-gray-900 mb-4">Caricature Result</h3>
          <div class="bg-gray-100 rounded-lg p-4 inline-block relative">
            <canvas id="caricature-canvas" width="400" height="400" class="border border-gray-300 rounded max-w-full" style="display: block; background: white;"></canvas>
            <div id="caricature-placeholder" class="absolute inset-0 flex items-center justify-center text-gray-500 pointer-events-none">
              <div class="text-center">
                <div class="text-4xl mb-2">ðŸŽ¨</div>
                <div class="text-sm">Your caricature will appear here</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Caricature Controls -->
        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              Caricature Style
            </label>
            <select id="caricature-style" class="w-full p-2 border border-gray-300 rounded-lg">
              <option value="cartoon">Cartoon Style</option>
              <option value="sketch">Sketch Style</option>
              <option value="comic">Comic Book Style</option>
              <option value="watercolor">Watercolor Style</option>
              <option value="pop-art">Pop Art Style</option>
            </select>
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              Exaggeration Level: <span id="exaggeration-value">50</span>%
            </label>
            <input 
              type="range" 
              id="exaggeration-slider" 
              min="10" 
              max="100" 
              step="10" 
              value="50" 
              class="w-full"
            />
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              Color Saturation: <span id="saturation-value">100</span>%
            </label>
            <input 
              type="range" 
              id="saturation-slider" 
              min="50" 
              max="200" 
              step="10" 
              value="100" 
              class="w-full"
            />
          </div>

          <!-- Generate Caricature Button -->
          <button 
            id="generate-caricature" 
            class="w-full bg-purple-600 text-white py-3 px-6 rounded-lg font-semibold hover:bg-purple-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
            disabled
          >
            Generate Caricature
          </button>

          <!-- Processing Status -->
          <div id="caricature-status" class="hidden">
            <div class="bg-purple-50 border border-purple-200 rounded-lg p-4">
              <div class="flex items-center">
                <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-purple-600 mr-2"></div>
                <span class="text-purple-800">Processing caricature...</span>
              </div>
            </div>
          </div>

          <!-- Success Message -->
          <div id="caricature-success" class="hidden">
            <div class="bg-green-50 border border-green-200 rounded-lg p-4">
              <div class="text-green-800 font-medium">âœ“ Caricature generated successfully!</div>
            </div>
          </div>

          <!-- Use for Marker Button -->
          <button 
            id="use-for-marker" 
            class="w-full bg-green-600 text-white py-3 px-6 rounded-lg font-semibold hover:bg-green-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
            disabled
          >
            Use This Caricature for Marker
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<script define:vars={{ config }}>
  class CaricatureGenerator {
    constructor() {
      this.originalCanvas = null;
      this.caricatureCanvas = null;
      this.originalImage = null;
      this.caricatureResult = null;
      this.init();
    }

    init() {
      // Check if canvas elements exist
      const originalCanvasEl = document.getElementById('original-canvas');
      const caricatureCanvasEl = document.getElementById('caricature-canvas');
      
      if (!originalCanvasEl || !caricatureCanvasEl) {
        console.error('Canvas elements not found');
        return;
      }

      try {
        // Initialize canvases
        this.originalCanvas = new fabric.Canvas('original-canvas', {
          backgroundColor: '#ffffff',
          selection: false,
          renderOnAddRemove: true,
          stateful: false
        });

        this.caricatureCanvas = new fabric.Canvas('caricature-canvas', {
          backgroundColor: '#ffffff',
          selection: false,
          renderOnAddRemove: true,
          stateful: false
        });

        // Bind events
        this.bindEvents();
        
        console.log('Caricature generator initialized successfully');
      } catch (error) {
        console.error('Error initializing caricature generator:', error);
      }
    }

    bindEvents() {
      // Image upload
      document.getElementById('caricature-upload').addEventListener('change', (e) => {
        this.handleImageUpload(e);
      });

      // Style and parameter controls
      document.getElementById('caricature-style').addEventListener('change', () => {
        this.updatePreview();
      });

      document.getElementById('exaggeration-slider').addEventListener('input', (e) => {
        document.getElementById('exaggeration-value').textContent = e.target.value;
        this.updatePreview();
      });

      document.getElementById('saturation-slider').addEventListener('input', (e) => {
        document.getElementById('saturation-value').textContent = e.target.value;
        this.updatePreview();
      });

      // Generate caricature
      document.getElementById('generate-caricature').addEventListener('click', () => {
        this.generateCaricature();
      });

      // Use for marker
      document.getElementById('use-for-marker').addEventListener('click', () => {
        this.useForMarker();
      });
    }

    handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        fabric.Image.fromURL(e.target.result, (img) => {
          // Clear existing image
          this.originalCanvas.clear();

          // Scale image to fit canvas
          const scale = Math.min(
            400 / img.width,
            400 / img.height
          );

          img.set({
            left: 200,
            top: 200,
            originX: 'center',
            originY: 'center',
            scaleX: scale,
            scaleY: scale,
            selectable: false
          });

          this.originalImage = img;
          this.originalCanvas.add(img);
          this.originalCanvas.renderAll();

          // Hide placeholder
          document.getElementById('original-placeholder').style.display = 'none';

          // Enable generate button
          document.getElementById('generate-caricature').disabled = false;
        });
      };
      reader.readAsDataURL(file);
    }

    updatePreview() {
      // This would update a live preview if we had real-time processing
      // For now, it's a placeholder for future enhancement
    }

    async generateCaricature() {
      if (!this.originalImage) {
        alert('Please upload an image first');
        return;
      }

      try {
        // Show loading state
        document.getElementById('caricature-status').classList.remove('hidden');
        document.getElementById('generate-caricature').disabled = true;

        // Get parameters
        const style = document.getElementById('caricature-style').value;
        const exaggeration = document.getElementById('exaggeration-slider').value;
        const saturation = document.getElementById('saturation-slider').value;

        // Get original image data
        const originalDataURL = this.originalCanvas.toDataURL('image/jpeg', 0.9);

        // Apply caricature effects
        const caricatureDataURL = await this.applyCaricatureEffects(
          originalDataURL, 
          style, 
          exaggeration, 
          saturation
        );

        // Display result
        fabric.Image.fromURL(caricatureDataURL, (img) => {
          this.caricatureCanvas.clear();

          const scale = Math.min(
            400 / img.width,
            400 / img.height
          );

          img.set({
            left: 200,
            top: 200,
            originX: 'center',
            originY: 'center',
            scaleX: scale,
            scaleY: scale,
            selectable: false
          });

          this.caricatureResult = img;
          this.caricatureCanvas.add(img);
          this.caricatureCanvas.renderAll();

          // Hide placeholder
          document.getElementById('caricature-placeholder').style.display = 'none';

          // Hide loading, show success
          document.getElementById('caricature-status').classList.add('hidden');
          document.getElementById('caricature-success').classList.remove('hidden');

          // Enable use for marker button
          document.getElementById('use-for-marker').disabled = false;
          document.getElementById('generate-caricature').disabled = false;
        });

      } catch (error) {
        console.error('Error generating caricature:', error);
        document.getElementById('caricature-status').classList.add('hidden');
        alert('Error generating caricature. Please try again.');
        document.getElementById('generate-caricature').disabled = false;
      }
    }

    async applyCaricatureEffects(imageDataURL, style, exaggeration, saturation) {
      // Create a temporary canvas for image processing
      const tempCanvas = document.createElement('canvas');
      const ctx = tempCanvas.getContext('2d');
      
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          tempCanvas.width = img.width;
          tempCanvas.height = img.height;
          
          // Draw original image
          ctx.drawImage(img, 0, 0);
          
          // Apply various caricature effects based on style
          this.applyStyleEffects(ctx, tempCanvas, style, exaggeration, saturation);
          
          resolve(tempCanvas.toDataURL('image/jpeg', 0.9));
        };
        img.src = imageDataURL;
      });
    }

    applyStyleEffects(ctx, canvas, style, exaggeration, saturation) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      // Apply saturation adjustment
      const saturationFactor = saturation / 100;
      
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        
        // Convert to grayscale
        const gray = 0.299 * r + 0.587 * g + 0.114 * b;
        
        // Apply saturation
        data[i] = Math.min(255, gray + saturationFactor * (r - gray));
        data[i + 1] = Math.min(255, gray + saturationFactor * (g - gray));
        data[i + 2] = Math.min(255, gray + saturationFactor * (b - gray));
      }

      // Apply style-specific effects
      switch (style) {
        case 'cartoon':
          this.applyCartoonEffect(data, canvas.width, canvas.height, exaggeration);
          break;
        case 'sketch':
          this.applySketchEffect(data, canvas.width, canvas.height);
          break;
        case 'comic':
          this.applyComicEffect(data, canvas.width, canvas.height, exaggeration);
          break;
        case 'watercolor':
          this.applyWatercolorEffect(data, canvas.width, canvas.height);
          break;
        case 'pop-art':
          this.applyPopArtEffect(data, canvas.width, canvas.height, exaggeration);
          break;
      }

      ctx.putImageData(imageData, 0, 0);
    }

    applyCartoonEffect(data, width, height, exaggeration) {
      // Quantize colors for cartoon effect
      const levels = Math.max(3, 8 - Math.floor(exaggeration / 20));
      
      for (let i = 0; i < data.length; i += 4) {
        data[i] = Math.floor(data[i] / (256 / levels)) * (256 / levels);
        data[i + 1] = Math.floor(data[i + 1] / (256 / levels)) * (256 / levels);
        data[i + 2] = Math.floor(data[i + 2] / (256 / levels)) * (256 / levels);
      }
    }

    applySketchEffect(data, width, height) {
      // Convert to grayscale and enhance edges
      for (let i = 0; i < data.length; i += 4) {
        const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
        const enhanced = Math.min(255, gray * 1.2);
        
        data[i] = enhanced;
        data[i + 1] = enhanced;
        data[i + 2] = enhanced;
      }
    }

    applyComicEffect(data, width, height, exaggeration) {
      // High contrast with color quantization
      const contrast = 1 + (exaggeration / 100);
      
      for (let i = 0; i < data.length; i += 4) {
        data[i] = Math.min(255, Math.max(0, (data[i] - 128) * contrast + 128));
        data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] - 128) * contrast + 128));
        data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] - 128) * contrast + 128));
      }
    }

    applyWatercolorEffect(data, width, height) {
      // Soft, blended colors
      for (let i = 0; i < data.length; i += 4) {
        data[i] = Math.min(255, data[i] * 0.9 + 25);
        data[i + 1] = Math.min(255, data[i + 1] * 0.9 + 25);
        data[i + 2] = Math.min(255, data[i + 2] * 0.9 + 25);
      }
    }

    applyPopArtEffect(data, width, height, exaggeration) {
      // High contrast, vibrant colors
      const boost = 1 + (exaggeration / 50);
      
      for (let i = 0; i < data.length; i += 4) {
        data[i] = Math.min(255, data[i] * boost);
        data[i + 1] = Math.min(255, data[i + 1] * boost);
        data[i + 2] = Math.min(255, data[i + 2] * boost);
      }
    }

    useForMarker() {
      if (!this.caricatureResult) {
        alert('Please generate a caricature first');
        return;
      }

      // Get the caricature as data URL
      const caricatureDataURL = this.caricatureCanvas.toDataURL('image/png', 1.0);
      
      // Store in sessionStorage to pass to the marker designer
      sessionStorage.setItem('caricatureImage', caricatureDataURL);
      
      // Navigate to the marker designer
      window.location.href = '/designer?source=caricature';
    }
  }

  // Initialize when DOM is loaded and Fabric.js is available
  function initializeCaricatureGenerator() {
    if (typeof fabric !== 'undefined') {
      new CaricatureGenerator();
    } else {
      // Wait for Fabric.js to load
      setTimeout(initializeCaricatureGenerator, 100);
    }
  }

  document.addEventListener('DOMContentLoaded', initializeCaricatureGenerator);
</script>