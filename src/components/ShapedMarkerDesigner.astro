---
import { config } from '../config';
---

<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
  <div class="bg-white rounded-lg shadow-lg p-6 lg:p-8">
    <h2 class="text-3xl font-bold text-gray-900 mb-8 text-center">Design Your Custom Marker</h2>
    
    <div class="grid xl:grid-cols-2 gap-8 lg:gap-12">
      <!-- Design Canvas -->
      <div class="space-y-6">
        <div class="text-center">
          <h3 class="text-xl font-semibold text-gray-900 mb-4">Preview</h3>
          <div class="bg-gray-100 rounded-lg p-6 inline-block max-w-full overflow-auto">
            <canvas id="marker-canvas" width={config.canvas.width} height={config.canvas.height} class="border border-gray-300 rounded max-w-full h-auto"></canvas>
          </div>
        </div>
        
        <!-- Canvas Controls -->
        <div class="flex flex-wrap gap-2 justify-center">
          <button id="reset-btn" class="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors">
            Reset
          </button>
          <button id="flip-horizontal" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors">
            Flip H
          </button>
          <button id="flip-vertical" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors">
            Flip V
          </button>
          <button id="rotate-left" class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors">
            ↺ Rotate
          </button>
        </div>
      </div>

      <!-- Controls Panel -->
      <div class="space-y-6">
        <!-- Image Upload -->
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            Upload Your Photo
          </label>
          <input 
            type="file" 
            id="image-upload" 
            accept="image/*" 
            class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-primary-50 file:text-primary-700 hover:file:bg-primary-100"
          />
        </div>

        <!-- Shape Selection -->
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            Choose Shape
          </label>
          <div class="grid grid-cols-3 gap-2">
            {config.shapes.map((shape) => (
              <button 
                class="shape-btn p-4 border-2 border-gray-300 rounded-lg text-center hover:border-primary-500 transition-colors"
                data-shape={shape.id}
              >
                <div class="text-2xl mb-1">{shape.icon}</div>
                <div class="text-sm font-medium">{shape.name}</div>
              </button>
            ))}
          </div>
        </div>

        <!-- Size Controls -->
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-2">
            Image Size
          </label>
          <input 
            type="range" 
            id="size-slider" 
            min="0.1" 
            max="2" 
            step="0.1" 
            value="1" 
            class="w-full"
          />
        </div>

        <!-- Generate Preview Button -->
        <button 
          id="generate-preview" 
          class="w-full bg-primary-600 text-white py-3 px-6 rounded-lg font-semibold hover:bg-primary-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
          disabled
        >
          Generate Preview & Upload
        </button>

        <!-- Upload Status -->
        <div id="upload-status" class="hidden">
          <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
            <div class="flex items-center">
              <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600 mr-2"></div>
              <span class="text-blue-800">Uploading to Cloudinary...</span>
            </div>
          </div>
        </div>

        <!-- Success Message -->
        <div id="upload-success" class="hidden">
          <div class="bg-green-50 border border-green-200 rounded-lg p-4">
            <div class="text-green-800 font-medium">✓ Preview uploaded successfully!</div>
            <div class="text-green-700 text-sm mt-1">Your custom marker is ready to order!</div>
          </div>
        </div>

        <!-- Add to Cart Button -->
        <button 
          id="add-to-cart"
          class="snipcart-add-item w-full bg-green-600 text-white py-3 px-6 rounded-lg font-semibold hover:bg-green-700 transition-all duration-300 disabled:bg-gray-400 disabled:cursor-not-allowed transform hover:scale-105"
          disabled
          data-item-id={config.product.id}
          data-item-price={config.product.price}
          data-item-description={config.product.name}
          data-item-name={config.product.name}
          data-item-url={`${config.baseUrl}/product/`}
          data-item-custom1-name="Preview Image URL"
          data-item-custom1-options=""
          data-item-custom1-value=""
        >
          Add to Cart - ${config.product.price}
        </button>
      </div>
    </div>
  </div>
</div>

<script define:vars={{ config }}>
  class MarkerDesigner {
    constructor() {
      this.canvas = null;
      this.uploadedImage = null;
      this.currentShape = 'circle';
      this.previewImageUrl = null;
      this.init();
    }

    init() {
      // Initialize Fabric.js canvas with performance optimizations
      this.canvas = new fabric.Canvas('marker-canvas', {
        backgroundColor: '#ffffff',
        selection: false,
        renderOnAddRemove: false, // Disable automatic rendering
        skipTargetFind: false,
        perPixelTargetFind: true,
        enableRetinaScaling: true,
        imageSmoothingEnabled: true
      });

      // Enable hardware acceleration
      this.canvas.getElement().style.imageRendering = 'auto';
      
      // Optimize canvas performance
      this.canvas.freeDrawingBrush.width = 1;
      this.canvas.freeDrawingBrush.color = '#000000';

      // Set initial shape
      this.setShape('circle');
      
      // Check for vectorized image from vectorize page
      this.checkForVectorizedImage();
      
      // Bind events
      this.bindEvents();
    }

    bindEvents() {
      // Image upload
      document.getElementById('image-upload').addEventListener('change', (e) => {
        this.handleImageUpload(e);
      });

      // Shape selection
      document.querySelectorAll('.shape-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const shape = e.currentTarget.dataset.shape;
          this.setShape(shape);
          this.updateShapeButtons(shape);
        });
      });

      // Size slider with throttling for better performance
      const sizeSlider = document.getElementById('size-slider');
      let sliderTimeout;
      sizeSlider.addEventListener('input', (e) => {
        const scale = parseFloat(e.target.value);
        
        // Clear previous timeout
        if (sliderTimeout) {
          clearTimeout(sliderTimeout);
        }
        
        // Throttle the scaling to improve performance
        sliderTimeout = setTimeout(() => {
          this.scaleImage(scale);
        }, 16); // ~60fps
      });

      // Control buttons
      document.getElementById('reset-btn').addEventListener('click', () => this.resetCanvas());
      document.getElementById('flip-horizontal').addEventListener('click', () => this.flipImage('horizontal'));
      document.getElementById('flip-vertical').addEventListener('click', () => this.flipImage('vertical'));
      document.getElementById('rotate-left').addEventListener('click', () => this.rotateImage());

      // Generate preview
      document.getElementById('generate-preview').addEventListener('click', () => {
        this.generateAndUploadPreview();
      });
    }

    handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        fabric.Image.fromURL(e.target.result, (img) => {
          // Remove existing image
          if (this.uploadedImage) {
            this.canvas.remove(this.uploadedImage);
          }

          // Scale image to fit canvas (use more space with larger canvas)
          const scale = Math.min(
            (config.canvas.width * 0.8) / img.width,
            (config.canvas.height * 0.8) / img.height
          );

          img.set({
            left: config.canvas.width / 2,
            top: config.canvas.height / 2,
            originX: 'center',
            originY: 'center',
            scaleX: scale,
            scaleY: scale,
            selectable: true,
            hasControls: true,
            hasBorders: true,
            moveable: true,
            evented: true
          });

          this.uploadedImage = img;
          this.canvas.add(img);
          
          // Ensure the canvas allows selection for this specific object
          this.canvas.selection = true;
          this.canvas.setActiveObject(img);
          this.canvas.selection = false; // Reset to prevent multi-selection
          
          this.canvas.renderAll();

          // Enable generate button
          document.getElementById('generate-preview').disabled = false;
        });
      };
      reader.readAsDataURL(file);
    }

    setShape(shapeType) {
      this.currentShape = shapeType;
      
      // Clear existing shapes
      this.canvas.getObjects().forEach(obj => {
        if (obj.isShape) {
          this.canvas.remove(obj);
        }
      });

      let shape;
      const centerX = config.canvas.width / 2;
      const centerY = config.canvas.height / 2;
      const size = Math.min(config.canvas.width, config.canvas.height) * 0.8;

      switch (shapeType) {
        case 'circle':
          shape = new fabric.Circle({
            radius: size / 2,
            left: centerX,
            top: centerY,
            originX: 'center',
            originY: 'center',
            fill: 'transparent',
            stroke: '#3b82f6',
            strokeWidth: 3,
            selectable: false,
            evented: false,
            isShape: true
          });
          break;
        case 'square':
          shape = new fabric.Rect({
            width: size,
            height: size,
            left: centerX,
            top: centerY,
            originX: 'center',
            originY: 'center',
            fill: 'transparent',
            stroke: '#3b82f6',
            strokeWidth: 3,
            selectable: false,
            evented: false,
            isShape: true
          });
          break;
        case 'shield':
          const shieldPath = `M ${centerX} ${centerY - size/2} 
                             C ${centerX + size/3} ${centerY - size/2}, ${centerX + size/2} ${centerY - size/4}, ${centerX + size/2} ${centerY} 
                             C ${centerX + size/2} ${centerY + size/3}, ${centerX + size/4} ${centerY + size/2}, ${centerX} ${centerY + size/2} 
                             C ${centerX - size/4} ${centerY + size/2}, ${centerX - size/2} ${centerY + size/3}, ${centerX - size/2} ${centerY} 
                             C ${centerX - size/2} ${centerY - size/4}, ${centerX - size/3} ${centerY - size/2}, ${centerX} ${centerY - size/2} Z`;
          
          shape = new fabric.Path(shieldPath, {
            fill: 'transparent',
            stroke: '#3b82f6',
            strokeWidth: 3,
            selectable: false,
            evented: false,
            isShape: true
          });
          break;
      }

      if (shape) {
        this.canvas.add(shape);
        this.canvas.sendToBack(shape);
        // Manual render since we disabled automatic rendering
        this.canvas.renderAll();
      }
    }

    updateShapeButtons(activeShape) {
      document.querySelectorAll('.shape-btn').forEach(btn => {
        btn.classList.remove('border-primary-500', 'bg-primary-50');
        btn.classList.add('border-gray-300');
      });
      
      const activeBtn = document.querySelector(`[data-shape="${activeShape}"]`);
      if (activeBtn) {
        activeBtn.classList.remove('border-gray-300');
        activeBtn.classList.add('border-primary-500', 'bg-primary-50');
      }
    }

    scaleImage(scale) {
      if (this.uploadedImage) {
        // Store the original scale if not already stored
        if (!this.originalScale) {
          this.originalScale = {
            scaleX: this.uploadedImage.scaleX,
            scaleY: this.uploadedImage.scaleY
          };
        }
        
        // Apply scale relative to original size
        this.uploadedImage.set({
          scaleX: this.originalScale.scaleX * scale,
          scaleY: this.originalScale.scaleY * scale
        });
        
        // Manual render since we disabled automatic rendering
        this.canvas.renderAll();
      }
    }

    flipImage(direction) {
      if (this.uploadedImage) {
        if (direction === 'horizontal') {
          this.uploadedImage.set('flipX', !this.uploadedImage.flipX);
        } else {
          this.uploadedImage.set('flipY', !this.uploadedImage.flipY);
        }
        // Manual render since we disabled automatic rendering
        this.canvas.renderAll();
      }
    }

    rotateImage() {
      if (this.uploadedImage) {
        this.uploadedImage.rotate(this.uploadedImage.angle + 90);
        // Manual render since we disabled automatic rendering
        this.canvas.renderAll();
      }
    }

    resetCanvas() {
      if (this.uploadedImage) {
        // Reset original scale tracking
        this.originalScale = null;
        
        this.uploadedImage.set({
          left: config.canvas.width / 2,
          top: config.canvas.height / 2,
          scaleX: 1,
          scaleY: 1,
          angle: 0,
          flipX: false,
          flipY: false
        });
        
        // Reset slider to default value
        const sizeSlider = document.getElementById('size-slider');
        if (sizeSlider) {
          sizeSlider.value = 1;
        }
        
        // Manual render since we disabled automatic rendering
        this.canvas.renderAll();
      }
    }

    async generateAndUploadPreview() {
      if (!this.uploadedImage) {
        alert('Please upload an image first');
        return;
      }
      
      try {
        console.log('Starting preview generation...');
        console.log('Current shape:', this.currentShape);
        console.log('Uploaded image:', this.uploadedImage);
        
        // Show loading state
        document.getElementById('upload-status').classList.remove('hidden');
        document.getElementById('generate-preview').disabled = true;

        // Create high-res export canvas
        console.log('Creating export canvas with dimensions:', config.canvas.exportWidth, 'x', config.canvas.exportHeight);
        let exportCanvas;
        try {
          exportCanvas = new fabric.Canvas(null, {
            width: config.canvas.exportWidth,
            height: config.canvas.exportHeight
          });
          console.log('Export canvas created successfully');
        } catch (canvasError) {
          console.error('Error creating export canvas:', canvasError);
          throw new Error(`Canvas creation failed: ${canvasError.message}`);
        }

        // Scale factor for high-res export
        const scaleFactor = config.canvas.exportWidth / config.canvas.width;
        console.log('Scale factor:', scaleFactor);

        // Clone and scale objects for export
        const objects = this.canvas.getObjects();
        console.log('Objects to clone:', objects.length);
        
        try {
           for (let i = 0; i < objects.length; i++) {
             const obj = objects[i];
             console.log(`Cloning object ${i + 1}/${objects.length}:`, obj.type);
             
             let cloned;
             
             // Special handling for image objects to avoid blob URL issues
              if (obj.type === 'image') {
                console.log('Creating new image object from data URL...');
                // Convert the image to a data URL to avoid blob URL issues
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                tempCanvas.width = obj.width * obj.scaleX;
                tempCanvas.height = obj.height * obj.scaleY;
               
               // Draw the image to the temporary canvas
               tempCtx.drawImage(obj.getElement(), 0, 0, tempCanvas.width, tempCanvas.height);
               const dataURL = tempCanvas.toDataURL('image/png');
               
               // Create a new fabric image from the data URL
               cloned = await new Promise((resolve, reject) => {
                 fabric.Image.fromURL(dataURL, (img) => {
                   if (img) {
                     resolve(img);
                   } else {
                     reject(new Error('Failed to create image from data URL'));
                   }
                 });
               });
             } else {
               cloned = await this.cloneObject(obj);
             }
             
             cloned.set({
               left: obj.left * scaleFactor,
               top: obj.top * scaleFactor,
               scaleX: obj.scaleX * scaleFactor,
               scaleY: obj.scaleY * scaleFactor
             });
             
             if (cloned.type === 'path') {
               cloned.set({
                 strokeWidth: obj.strokeWidth * scaleFactor
               });
             } else if (cloned.type === 'circle' || cloned.type === 'rect') {
               cloned.set({
                 strokeWidth: obj.strokeWidth * scaleFactor
               });
               if (cloned.type === 'circle') {
                 cloned.set({ radius: obj.radius * scaleFactor });
               } else {
                 cloned.set({
                   width: obj.width * scaleFactor,
                   height: obj.height * scaleFactor
                 });
               }
             }
             
             exportCanvas.add(cloned);
           }
          console.log('All objects cloned successfully');
        } catch (cloneError) {
          console.error('Error cloning objects:', cloneError);
          throw new Error(`Object cloning failed: ${cloneError.message}`);
        }

        console.log('Rendering export canvas...');
        try {
          exportCanvas.renderAll();
          console.log('Export canvas rendered successfully');
        } catch (renderError) {
          console.error('Error rendering export canvas:', renderError);
          throw new Error(`Canvas rendering failed: ${renderError.message}`);
        }

        console.log('Applying shape mask...');
        let dataURL;
        try {
          dataURL = this.applyShapeMask(exportCanvas);
          console.log('Shape mask applied successfully, dataURL length:', dataURL.length);
        } catch (maskError) {
          console.error('Error applying shape mask:', maskError);
          throw new Error(`Shape masking failed: ${maskError.message}`);
        }
        
        console.log('Uploading to Cloudinary...');
        let imageUrl;
        try {
          imageUrl = await this.uploadToCloudinary(dataURL);
          console.log('Upload successful, image URL:', imageUrl);
        } catch (uploadError) {
          console.error('Error uploading to Cloudinary:', uploadError);
          throw new Error(`Upload failed: ${uploadError.message}`);
        }
        
        this.previewImageUrl = imageUrl;
        
        // Hide loading, show success
        document.getElementById('upload-status').classList.add('hidden');
        document.getElementById('upload-success').classList.remove('hidden');
        
        // Enable add to cart with visual feedback
        const addToCartBtn = document.getElementById('add-to-cart');
        addToCartBtn.disabled = false;
        addToCartBtn.setAttribute('data-item-custom1-value', imageUrl);
        addToCartBtn.setAttribute('data-item-url', `${config.baseUrl}/product/`);
        
        // Add visual feedback - subtle pulse animation
        addToCartBtn.classList.add('animate-pulse');
        setTimeout(() => {
          addToCartBtn.classList.remove('animate-pulse');
        }, 2000); // Remove pulse after 2 seconds
        
        // Re-enable generate button
        document.getElementById('generate-preview').disabled = false;

      } catch (error) {
        console.error('Error generating preview:', error);
        console.error('Error stack:', error.stack);
        document.getElementById('upload-status').classList.add('hidden');
        
        // Show more specific error message
        let errorMessage = 'Error generating preview. Please try again.';
        if (error.message.includes('Cloudinary') || error.message.includes('Upload')) {
          errorMessage = 'Upload service temporarily unavailable. Please try again later.';
        } else if (error.message.includes('network') || error.message.includes('fetch')) {
          errorMessage = 'Network error. Please check your connection and try again.';
        } else if (error.message.includes('Canvas') || error.message.includes('rendering')) {
          errorMessage = 'Image processing error. Please try again.';
        }
        
        alert(errorMessage);
        document.getElementById('generate-preview').disabled = false;
      }
    }

    async cloneObject(obj) {
      return new Promise((resolve, reject) => {
        try {
          obj.clone((cloned) => {
            if (cloned) {
              resolve(cloned);
            } else {
              console.error('Failed to clone object:', obj.type);
              reject(new Error(`Failed to clone ${obj.type} object`));
            }
          });
        } catch (error) {
          console.error('Error during object cloning:', error);
          reject(error);
        }
      });
    }

    applyShapeMask(fabricCanvas) {
      // Get the underlying canvas element from Fabric.js canvas
      const canvas = fabricCanvas.getElement();
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      
      // Create mask based on shape
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = canvas.width;
      maskCanvas.height = canvas.height;
      const maskCtx = maskCanvas.getContext('2d', { willReadFrequently: true });
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const size = Math.min(canvas.width, canvas.height) * 0.8;
      
      maskCtx.fillStyle = 'black';
      
      switch (this.currentShape) {
        case 'circle':
          maskCtx.beginPath();
          maskCtx.arc(centerX, centerY, size / 2, 0, 2 * Math.PI);
          maskCtx.fill();
          break;
        case 'square':
          maskCtx.fillRect(centerX - size/2, centerY - size/2, size, size);
          break;
        case 'shield':
          maskCtx.beginPath();
          maskCtx.moveTo(centerX, centerY - size/2);
          maskCtx.bezierCurveTo(centerX + size/3, centerY - size/2, centerX + size/2, centerY - size/4, centerX + size/2, centerY);
          maskCtx.bezierCurveTo(centerX + size/2, centerY + size/3, centerX + size/4, centerY + size/2, centerX, centerY + size/2);
          maskCtx.bezierCurveTo(centerX - size/4, centerY + size/2, centerX - size/2, centerY + size/3, centerX - size/2, centerY);
          maskCtx.bezierCurveTo(centerX - size/2, centerY - size/4, centerX - size/3, centerY - size/2, centerX, centerY - size/2);
          maskCtx.closePath();
          maskCtx.fill();
          break;
      }
      
      // Apply mask
      const maskData = maskCtx.getImageData(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < imageData.data.length; i += 4) {
        if (maskData.data[i] === 0) { // Outside mask
          imageData.data[i + 3] = 0; // Make transparent
        }
      }
      
      ctx.putImageData(imageData, 0, 0);
      return canvas.toDataURL('image/png', 1.0);
    }

    async uploadToCloudinary(dataURL) {
      // Check if Cloudinary is properly configured
      if (config.cloudinary.cloudName === 'your_cloudinary_cloud_name' || 
          config.cloudinary.uploadPreset === 'your_unsigned_upload_preset') {
        console.error('Cloudinary not configured. Using placeholder image.');
        // Return a placeholder image URL for development
        return 'https://via.placeholder.com/400x400/3b82f6/ffffff?text=Preview+Generated';
      }

      try {
        console.log('Uploading to Cloudinary with config:', {
          cloudName: config.cloudinary.cloudName,
          uploadPreset: config.cloudinary.uploadPreset
        });

        const formData = new FormData();
        
        // Convert dataURL to blob
        const response = await fetch(dataURL);
        const blob = await response.blob();
        
        console.log('Blob size:', blob.size, 'bytes');
        
        formData.append('file', blob);
        formData.append('upload_preset', config.cloudinary.uploadPreset);
        
        const uploadUrl = `https://api.cloudinary.com/v1_1/${config.cloudinary.cloudName}/image/upload`;
        console.log('Upload URL:', uploadUrl);
        
        const uploadResponse = await fetch(uploadUrl, {
          method: 'POST',
          body: formData
        });
        
        console.log('Upload response status:', uploadResponse.status);
        
        if (!uploadResponse.ok) {
          const errorText = await uploadResponse.text();
          console.error('Upload failed with status:', uploadResponse.status, 'Error:', errorText);
          throw new Error(`Upload failed: ${uploadResponse.status} - ${errorText}`);
        }
        
        const result = await uploadResponse.json();
        console.log('Upload successful:', result.secure_url);
        return result.secure_url;
        
      } catch (error) {
        console.error('Cloudinary upload error:', error);
        throw new Error(`Failed to upload to Cloudinary: ${error.message}`);
      }
    }

    checkForVectorizedImage() {
      // Check if there's a vectorized image from the vectorize page
      const vectorizedData = sessionStorage.getItem('vectorizedImage');
      if (vectorizedData) {
        this.loadVectorizedImage(JSON.parse(vectorizedData));
        // Clear the stored data after loading
        sessionStorage.removeItem('vectorizedImage');
      }
    }



    loadVectorizedImage(vectorData) {
      // Create a blob URL from the SVG string to avoid CORS issues
      const svgBlob = new Blob([vectorData.svgString], { type: 'image/svg+xml' });
      const svgUrl = URL.createObjectURL(svgBlob);
      
      fabric.Image.fromURL(svgUrl, (img) => {
        // Clean up the blob URL
        URL.revokeObjectURL(svgUrl);
        
        // Remove existing image
        if (this.uploadedImage) {
          this.canvas.remove(this.uploadedImage);
        }

        // Scale image to fit canvas (use more space with larger canvas)
        const scale = Math.min(
          (config.canvas.width * 0.8) / img.width,
          (config.canvas.height * 0.8) / img.height
        );

        img.set({
          left: config.canvas.width / 2,
          top: config.canvas.height / 2,
          originX: 'center',
          originY: 'center',
          scaleX: scale,
          scaleY: scale,
          selectable: true,
          hasControls: true,
          hasBorders: true,
          moveable: true,
          evented: true
        });

        this.uploadedImage = img;
        this.canvas.add(img);
        
        // Ensure the canvas allows selection for this specific object
        this.canvas.selection = true;
        this.canvas.setActiveObject(img);
        this.canvas.selection = false; // Reset to prevent multi-selection
        
        // Store original scale for proper scaling calculations
        this.originalScale = {
          scaleX: scale,
          scaleY: scale
        };
        
        // Manual render since we disabled automatic rendering
        this.canvas.renderAll();

        // Enable generate button
        document.getElementById('generate-preview').disabled = false;
        
        // Show success message with user details
        const successDiv = document.createElement('div');
        successDiv.className = 'bg-green-50 border border-green-200 rounded-lg p-4 mb-4';
        successDiv.innerHTML = `
          <div class="text-green-800 font-medium">✓ Vectorized image loaded successfully!</div>
          <div class="text-green-700 text-sm mt-1">Project: ${vectorData.userDetails.projectName} | User: ${vectorData.userDetails.name}</div>
        `;
        document.querySelector('.space-y-6').insertBefore(successDiv, document.querySelector('.space-y-6').firstChild);
        
        // Remove message after 5 seconds
        setTimeout(() => {
          successDiv.remove();
        }, 5000);
      }, { crossOrigin: 'anonymous' });
    }
  }

  // Initialize when DOM is loaded and Fabric.js is available
  function initializeDesigner() {
    if (typeof fabric !== 'undefined') {
      // Log configuration for debugging
      console.log('Cloudinary Configuration:', {
        cloudName: config.cloudinary.cloudName,
        uploadPreset: config.cloudinary.uploadPreset,
        isConfigured: config.cloudinary.cloudName !== 'your_cloudinary_cloud_name' && 
                     config.cloudinary.uploadPreset !== 'your_unsigned_upload_preset'
      });
      
      new MarkerDesigner();
    } else {
      // Wait for Fabric.js to load
      setTimeout(initializeDesigner, 100);
    }
  }

  document.addEventListener('DOMContentLoaded', initializeDesigner);
</script>